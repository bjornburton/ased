\input cwebmac

% ased

\nocon % omit table of contents
\datethis % print date on listing


\N{1}{1}Introduction. This is the firmware portion of an Ancillary Service
Electric Detector or ASED.

With my emergency generator connected through an interlocked load-center, it's
hard to tell when the \PB{\\{Ancillary}\\{Service}} has been restored.
The neighbor's lights offer a clue at night, but aren't reliable.
Switching back to Main, from the genny, requires shutting  everything down for
a moment.
It would be good to know if main, or Ancillary Service, is live before
switching back to it.

The obvious method is to measure the voltage at the main-breaker's input, using
a meter.
One safety concern is that it's not breaker-protected making for a massive
fault-current, should insulation be breached or the circuit shorted.
Also, installation of a simple meter is somewhat involved, having to tap into
live lines and, ideally, providing some form of isolation.

The obvious solution is to have a high-impedance connection very near to the
source.
A small capacitance would do.
Simple capacitive coupling can be had with a ``gimmick''; a technique used
since the 1920s.
This may be several turns of THHN around the large-gage insulated incoming
line.
Since the voltage is with respect to neutral, and neutral is bonded to ground,
just the one wire is needed to get a ``sample''.
No need to mess with live conductors, just coupling to the electric field
through the insulation already present.
Installation still has some risk, but much less.

This is still not Double insulated, so whatever gizmo is connected should
provide an additional level of protection, but it's better than a copper
connection.

With access to this signal, a circuit can be built to detect the difference
between having AC and not having AC, providing a signal to indicate that state.
The signal provided to the generator-operator could be a lamp or buzzer.

Looking at some numbers, the line-voltage is $\pm$ 170~V peak, with respect to
ground.
The peaks will be about 8.3~ms apart, in North America.
The signal we  will see will be much less, depending on the circuit's input
impedance and capacitance, but should be good..

The circuit would need a high input impedance, so as to see a strong enough
signal.
The circuit would need a reference to ground to compare to.
The input may need a bit of protection from line transients, which could pass
trough the gimmick.

I had seven Adafruit Industry Trinkets just laying around. They use the Atmel
ATTINY85 processor. The analog inputs are about 100~M$\Omega$. Not great, but
I think it should be good enough. If we can muster 1~pf of gimmick, we will
have $\ {1 \over 2 \pi f_c} $ of $X_c$. Ohms law indicates
$100e6 {170 \over  {(2pi*60*1e-12)^{-1} + 100e6)} } = 6.16 $ volts peak,
ignoring
input pin capacitance. The steering diodes will keep the analog innards safe
since the current is so low. Supply voltage at "BAT" is 5.5 to 16~V and it has
a red LED on-board.


\fi

\N{1}{2}Implementation and Specification.
Extensive use was made of the datasheet, Atmel ``Atmel ATtiny25, ATtiny45,
ATtiny85 Datasheet'' Rev. 2586Q–AVR–08/2013 (Tue 06 Aug 2013 03:19:12 PM
EDT).

In use, the AC signal goes to the pin  marked \#2 on the Trinket, PB2 on the
chip, and in the Atmel  datasheet.
The LED port is marked \#1, which is PB1.
The Siren port is marked \#0, and is PB0.
Clear is on \#3, PB3 on the chip.


\fi

\M{3}\PB{\.{"F\_CPU"}} is used only to convey the Trinket clock rate to
delay.h.
\Y\B\4\D$\.{F\_CPU}$ \5
\T{8000000\$U\$L}\par
\fi

\M{4}Here are some basic Boolean definitions that are used.
\Y\B\4\D$\.{ON}$ \5
\T{1}\par
\B\4\D$\.{OFF}$ \5
\T{0}\par
\B\4\D$\.{SET}$ \5
\T{1}\par
\B\4\D$\.{CLEAR}$ \5
\T{0}\par
\fi

\M{5}Bit flags within the f\_state bit array defined later.
\Y\B\4\D$\.{NOWAVES}$ \5
\T{2}\SHC{ no ASE detected for some time }\par
\B\4\D$\.{WAVES}$ \5
\T{1}\SHC{ ASE detected }\par
\B\4\D$\.{ARM}$ \5
\T{0}\SHC{ ARM for Alarm }\par
\fi

\M{6}\PB{\.{"WAVETHRESHOLD"}} is the number of waves, that AC must be present
to consider it `ON'.
15 counts, or waves,  maybe about 250 ms.
Range is 0 to 255 but don't take too long or the timer will nowave timer
overflow.
\Y\B\4\D$\.{WAVETHRESHOLD}$ \5
\T{15}\par
\fi

\M{7}The prescaler is set to clk/16484 at \PB{$\X29:Initialize the no-wave
timer\X$}.
\PB{\.{"NOWAVETIME"}} is the timer preset so that overflow happens in about
500~ms.
The math goes: $0.5 seconds *(8e6 /over 16384) = 244.14$.
Then to overflow, $256-244 = 12$, thus leaving 500 ms until time-out, unless it
is reset.
\Y\B\4\D$\.{NOWAVETIME}$ \5
\T{12}\SHC{ preset for the timer counter. Range to 255 */ }\par
\fi

\M{8} This is the hold-off time in $\mu$s for wave detection. This value is
used by the \PB{\.{"\_delay\_us()"}} function here \PB{$\X32:Hold-off all
interrupts\X$}.
\Y\B\4\D$\.{WAVEHOLDOFFTIME}$ \5
\T{100}\SHC{ Range to 255 }\par
\fi

\M{9}Alarm arm delay in ``nowave'' counts of whose size is defined by \PB{%
\.{"NOWAVETIME"}}.
\Y\B\4\D$\.{ARMTHRESHOLD}$ \5
\T{1200}\SHC{ Range to 65535 }\par
\fi

\M{10}Chirp parameters for alarm. These unit are of period $1 \over f$.
\Y\B\4\D$\.{CHIRPLENGTH}$ \5
\T{7}\SHC{ number of waves long }\par
\B\4\D$\.{CHIRPPERIOD}$ \5
\T{200}\SHC{ number of waves long }\par
\fi

\M{11}\B\X11:Include\X${}\E{}$\6
\8\#\&{include} \.{<avr/io.h>}\SHC{ need some port access }\6
\8\#\&{include} \.{<util/delay.h>}\SHC{ need to delay }\6
\8\#\&{include} \.{<avr/interrupt.h>}\SHC{ have need of an interrupt }\6
\8\#\&{include} \.{<avr/sleep.h>}\SHC{ have need of sleep }\6
\8\#\&{include} \.{<stdlib.h>}\par
\U14.\fi

\M{12}\B\X12:Prototypes\X${}\E{}$\6
\&{void} \\{ledcntl}(\&{char} \\{state});\SHC{ LED ON and LED OFF }\6
\&{void} \\{sirencntl}(\&{char} \\{state});\SHC{ alarm siren control }\6
\&{void} \\{chirp}(\&{char} \\{state});\SHC{ alarm siren modulation }\par
\U14.\fi

\M{13}
The f\_state global variable needs the type qualifier `volatile' or
optimization may eliminate it.
f\_state is just a simple bit-flag array that keeps track what has been
handled.

\Y\B\4\X13:Global variables\X${}\E{}$\6
\&{volatile} \&{unsigned} \&{char} \\{f\_state}${}\K\T{0}{}$;\par
\U14.\fi

\M{14}
Here is \PB{\\{main}}. Atmel pins default as simple inputs so the first thing
is to configure to use LED, Siren pins as outputs.
Additionally, we need the clear button to wake the device through an interrupt.
\Y\B\X11:Include\X\6
\X12:Prototypes\X\6
\X13:Global variables\X\6
\&{int} \\{main}(\&{void})\1\1 $\{$ \X27:Initialize pin outputs and inputs\X\par
\fi

\M{15}
The LED is set, meaning `on', assuming that there is an AC signal.
The thought is that it's better to say that there is AC, when there isn't, as
opposed to the converse.
\Y\B\C{ turn the led on }\6
\\{ledcntl}(\.{ON});\par
\fi

\M{16}
Here the timer and comparator are setup.
\Y\B\X29:Initialize the no-wave timer\X\par
\fi

\M{17}
The Trinket runs at relatively speedy 8 MHz so the slow 60 Hz signal is no
issue.
One could use the ADC but that doesn't make too much sense as the input may
spend a lot of time clipped.
We just need to know when the signal changes.
The inbuilt comparator seems like the right choice, for now.

\Y\B\X30:Initialize the wave detection\X\par
\fi

\M{18}
Of course, any interrupt function requires that bit ``Global Interrupt Enable''
is set; usually done through calling sei().
\Y\B\\{sei}(\,);\par
\fi

\M{19}
Rather than burning loops, waiting for something to happen for 16 ms, the sleep
mode is used.
The specific type of `sleep' is `idle'.
Interrupts are used to wake it.
\Y\B\X31:Configure to wake upon interrupt\X\par
\fi

\M{20}
This is the loop that does the work. It should spend most of its time in \PB{%
\\{sleep\_mode}}, cumming out at each interrupt event.

\Y\B\&{for} ( ;  ; \,)\SHC{ forever }\6
$\{$ \&{static} \&{unsigned} \&{char} \\{waveless}${}\K\.{WAVETHRESHOLD};{}$\6
\&{static} \&{unsigned} \&{int} \\{armwait}${}\K\.{ARMTHRESHOLD}{}$;\par
\fi

\M{21}
Now we wait in ``idle'' for any interrupt event.
\Y\B\\{sleep\_mode}(\,);\par
\fi

\M{22}
If execution arrives here, some interrupt has been detected.
It could be that a sinewave was detected.
It could be that the NOWAVES timer overflowed, since there have been no
sinewaves for an extended period.
It could be that the siren was so annoying that the operator pressed the
``Clear'' button.

In the case of a ``Clear'' event, its ISR does the work and program flow passes
over most of this.
If a wave is detected, it's counted. Once the counter reaches zero, the light
and, if armed, the siren are activated. Also, the timer for nowave is reset;
after all, there is a wave. Each time the interrupt is processed, its flag is
reset for use in the next pass.

If the nowave timer overflows, almost the opposite happens. The LED and siren
are turned off. The waveless counter is reset. After some passes, the siren
will be armed. Finally, the flag is reset, as before.

As a side note, while activities could have been performed within the ISRs, it
doesn't make it much simpler and actually makes the code somewhat larger.
My guess is that optimization doesn't work well across ISRs.

The ISR would have left a flag set in \PB{\\{f\_state}}.
Let's see which one by testing each possibility and acting on it.
\Y\B\&{if} ${}(\\{f\_state}\AND(\T{1}\LL\.{WAVES})){}$\5
${}\{{}$\1\6
${}\\{waveless}\K(\\{waveless})\?\\{waveless}-\T{1}:\T{0}{}$;\SHC{ countdown to
0, but not lower }\6
\&{if} ${}(\R\\{waveless}{}$)\SHC{ ancillary electric service restored }\6
${}\{{}$\1\6
\\{ledcntl}(\.{ON});\6
\&{if} ${}(\\{f\_state}\AND(\T{1}\LL\.{ARM})){}$\1\5
\\{chirp}(\.{ON});\SHC{  annunciate }\2\6
${}\.{TCNT1}\K\.{NOWAVETIME}{}$;\SHC{ reset the nowave timer }\6
\4${}\}{}$\SHC{ end if waveless }\2\6
${}\\{f\_state}\MRL{\AND{\K}}\CM(\T{1}\LL\.{WAVES}){}$;\SHC{reset int flag
since actions are complete }\6
\4${}\}{}$\SHC{ end if WAVES }\2\6
\&{else} \&{if} ${}(\\{f\_state}\AND(\T{1}\LL\.{NOWAVES})){}$\5
${}\{{}$\1\6
\\{ledcntl}(\.{OFF});\6
\\{chirp}(\.{OFF});\SHC{ ASE dropped, stop alarm chirp }\6
${}\\{waveless}\K\.{WAVETHRESHOLD}{}$;\SHC{ waveless again }\6
${}\\{armwait}\K(\\{armwait})\?\\{armwait}-\T{1}:\T{0}{}$;\SHC{ countdown to 0,
but not lower }\6
\&{if} ${}(\R\\{armwait}\W\CM\\{f\_state}\AND(\T{1}\LL\.{ARM})){}$\1\5
${}\\{f\_state}\MRL{{\OR}{\K}}(\T{1}\LL\.{ARM});{}$\2\6
${}\\{f\_state}\MRL{\AND{\K}}\CM(\T{1}\LL\.{NOWAVES}){}$;\SHC{reset int flag }\6
\4${}\}{}$\SHC{ end if NOWAVES }\2\6
\X32:Hold-off all interrupts\X $\}{}$\SHC{ end for }\6
\&{return} \T{0};\SHC{ it's the right thing to do! }\6
$\}{}$\SHC{ end main }\par
\fi

\M{23}
This is the ISR for the main timer.
When this overflows it generally means the ASE has been off for as long as it
took \PB{\.{TCINT1}} to overflow from it's start at \PB{\.{NOWAVETIME}}.
\Y\B\C{ Timer ISR }\6
\.{ISR}(\\{TIMER1\_OVF\_vect})\1\1\2\2\6
${}\{{}$\1\6
${}\\{f\_state}\MRL{{\OR}{\K}}(\T{1}\LL\.{NOWAVES});{}$\6
\4${}\}{}$\2\par
\fi

\M{24}
This vector responds to falling comparator events resulting from ac AC signal
at the MUX input.
\Y\B\C{ Comparator ISR }\6
\.{ISR}(\\{ANA\_COMP\_vect})\1\1\2\2\6
${}\{{}$\1\6
${}\\{f\_state}\MRL{{\OR}{\K}}(\T{1}\LL\.{WAVES});{}$\6
\4${}\}{}$\2\par
\fi

\M{25}
This ISR responds to the Clear button at pin \#3 or PB3.
\Y\B\C{ Clear Button ISR }\6
\.{ISR}(\\{PCINT0\_vect})\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\.{PORTB}\AND(\T{1}\LL\.{PORTB3})){}$\1\5
${}\\{f\_state}\MRL{\AND{\K}}\CM(\T{1}\LL\.{ARM});{}$\2\6
\4${}\}{}$\2\par
\fi

\N{1}{26}These are the supporting routines and configuration blocks.

\fi

\M{27}\B\X27:Initialize pin outputs and inputs\X${}\E{}$\6
${}\{{}$\C{ set the led port direction; This is pin \#1 }\1\6
${}\.{DDRB}\MRL{{\OR}{\K}}(\T{1}\LL\.{DDB1}){}$;\C{ set the siren port
direction }\6
${}\.{DDRB}\MRL{{\OR}{\K}}(\T{1}\LL\.{DDB0}){}$;\C{ enable pin change interrupt
for clear-button}\6
${}\.{PCMSK}\MRL{{\OR}{\K}}(\T{1}\LL\.{PCINT3}){}$;\C{ General interrupt Mask
register for clear-button}\6
${}\.{GIMSK}\MRL{{\OR}{\K}}(\T{1}\LL\.{PCIE});{}$\6
\4${}\}{}$\2\par
\U14.\fi

\M{28}
Siren function will arm after a 10 minute power-loss; that is,
the Trinket is running for about 10 minutes without seeing AC at pin \#2.
Once armed, siren will chirp for 100 ms at a 5 second interval,
only while AC is present. In fact it is called with each AC cycle interrupt so
that \PB{\.{CHIRPLENGTH}} and \PB{\.{CHIRPPERIOD}} are defined a multiples of
${1 \over Hz}$.
It may be disarmed, stopping the chirp, by pressing a button or power-cycle.

\Y\B\&{void} \\{chirp}(\&{char} \\{state})\1\1\2\2\6
${}\{{}$\1\6
\&{static} \&{unsigned} \&{char} \\{count}${}\K\.{CHIRPLENGTH};{}$\7
${}\\{count}\K(\\{count})\?\\{count}-\T{1}:\.{CHIRPPERIOD};{}$\6
\&{if} ${}(\\{count}>\.{CHIRPLENGTH}\V\\{state}\E\.{OFF}){}$\1\5
\\{sirencntl}(\.{OFF});\2\6
\&{else}\1\5
\\{sirencntl}(\.{ON});\2\6
\4${}\}{}$\2\7
\&{void} \\{ledcntl}(\&{char} \\{state})\1\1\2\2\6
${}\{{}$\1\6
${}\.{PORTB}\K\\{state}\?\.{PORTB}\OR(\T{1}\LL\.{PORTB1}):\.{PORTB}\AND\CM(%
\T{1}\LL\.{PORTB1});{}$\6
\4${}\}{}$\C{ simple siren control }\2\7
\&{void} \\{sirencntl}(\&{char} \\{state})\1\1\2\2\6
${}\{{}$\1\6
${}\.{PORTB}\K\\{state}\?\.{PORTB}\OR(\T{1}\LL\.{PORTB0}):\.{PORTB}\AND\CM(%
\T{1}\LL\.{PORTB0});{}$\6
\4${}\}{}$\2\par
\fi

\M{29}
A timer is needed to to encompass some number of waves so it can clearly
discern on from off.
The timer is also interrupt based. The timer is set to interrupt at overflow.
It could overflow within about $1 \over 2$ second.
Over the course of that time, 25 to 30 comparator interrupts are expected.
When the timer interrupt does occur, the LED is switched off.
Comparator Interrupts are counted and at 15 the timer is reset and the LED is
switched on.

\Y\B\4\X29:Initialize the no-wave timer\X${}\E{}$\6
${}\{{}$\SHC{set a very long prescale of 16384 counts }\1\6
${}\.{TCCR1}\K((\T{1}\LL\.{CS10})\OR(\T{1}\LL\.{CS11})\OR(\T{1}\LL\.{CS12})\OR(%
\T{1}\LL\.{CS13})){}$;\C{ Timer/counter 1 f\_overflow interrupt enable }\6
${}\.{TIMSK}\MRL{{\OR}{\K}}(\T{1}\LL\.{TOIE1});{}$\6
\4${}\}{}$\2\par
\Q7.
\U16.\fi

\M{30}
The ideal input AN1 (PB1), is connected to the LED in the Trinket!
That's not a big issue since the ADC's MUX may be used.
That MUX may address PB2, PB3, PB4 or PB5. Of those, PB2, PB3 and PB4 are
available.
Since PB3 and PB4 are use for USB, PB2 makes sense here.
This is marked \#2 on the Trinket.
PB2 connects the the MUX's ADC1.
Use of the MUX is selected by setting bit ACME of port ADCSRB. ADC1 is set by
setting bit MUX0 of register ADMUX


Disable digital input buffers at AIN[1:0] to save power. This is done by
setting AIN1D and AIN0D in register DIDR0.

Both comparator inputs have pins but AIN0 can be connected to a reference of
1.1 VDC, leaving the negative input to the signal. The ref is selected by
setting bit ACBG of register ACSR.


It can be configured to trigger on rising, falling or toggle (default) by
clearing/setting bits ACIS[1:0] also on register ACSR.
There is no need for toggle, and falling is selected by simply setting ACIS1.


To enable this interrupt, set the ACIE bit of register ACSR.
\Y\B\4\X30:Initialize the wave detection\X${}\E{}$\6
${}\{{}$\C{ Setting bit ACME of port ADCSRB to enable the MUX input ADC1 }\1\6
${}\.{ADCSRB}\MRL{{\OR}{\K}}(\T{1}\LL\.{ACME}){}$;\C{ ADC1 is set by setting
bit MUX0 of register ADMUX }\6
${}\.{ADMUX}\MRL{{\OR}{\K}}(\T{1}\LL\.{MUX0}){}$;\C{ Disable digital inputs to
save power }\6
${}\.{DIDR0}\MRL{{\OR}{\K}}((\T{1}\LL\.{AIN1D})\OR(\T{1}\LL\.{AIN0D})){}$;\C{
Connect the + input to the band-gap reference }\6
${}\.{ACSR}\MRL{{\OR}{\K}}(\T{1}\LL\.{ACBG}){}$;\C{ Trigger on falling edge
only }\6
${}\.{ACSR}\MRL{{\OR}{\K}}(\T{1}\LL\.{ACIS1}){}$;\C{ Enable the analog
comparator interrupt }\6
${}\.{ACSR}\MRL{{\OR}{\K}}(\T{1}\LL\.{ACIE});{}$\6
\4${}\}{}$\2\par
\U17.\fi

\M{31}
Setting these bits configure sleep\_mode() to go to ``idle''.
Idle allows the counters and comparator to continue during sleep.

\Y\B\4\X31:Configure to wake upon interrupt\X${}\E{}$\6
${}\{{}$\1\6
${}\.{MCUCR}\MRL{\AND{\K}}\CM(\T{1}\LL\.{SM1});{}$\6
${}\.{MCUCR}\MRL{\AND{\K}}\CM(\T{1}\LL\.{SM0});{}$\6
\4${}\}{}$\2\par
\U19.\fi

\M{32}\B\X32:Hold-off all interrupts\X${}\E{}$\6
${}\{{}$\C{ Disable the analog comparator interrupt }\1\6
${}\.{ACSR}\MRL{\AND{\K}}\CM(\T{1}\LL\.{ACIE});{}$\6
\\{\_delay\_us}(\.{WAVEHOLDOFFTIME});\C{ Enable the analog comparator interrupt
}\6
${}\.{ACSR}\MRL{{\OR}{\K}}(\T{1}\LL\.{ACIE});{}$\6
\4${}\}{}$\2\par
\Q8.
\U22.\fi

\M{33}
Done

\fi


\inx
\fin
\con
